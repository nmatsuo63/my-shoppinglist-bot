"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const api_1 = require("../api");
const logging_1 = require("../logging");
/**
 * Plugin to search AMIs for the current account
 */
class AmiContextProviderPlugin {
    constructor(aws) {
        this.aws = aws;
    }
    async getValue(args) {
        const region = args.region;
        const account = args.account;
        // Normally we'd do this only as 'debug', but searching AMIs typically takes dozens
        // of seconds, so be little more verbose about it so users know what is going on.
        logging_1.print(`Searching for AMI in ${account}:${region}`);
        logging_1.debug(`AMI search parameters: ${JSON.stringify(args)}`);
        const ec2 = (await this.aws.forEnvironment(account, region, api_1.Mode.ForReading)).ec2();
        const response = await ec2.describeImages({
            Owners: args.owners,
            Filters: Object.entries(args.filters).map(([key, values]) => ({
                Name: key,
                Values: values
            }))
        }).promise();
        const images = [...response.Images || []].filter(i => i.ImageId !== undefined);
        if (images.length === 0) {
            throw new Error('No AMI found that matched the search criteria');
        }
        // Return the most recent one
        // Note: Date.parse() is not going to respect the timezone of the string,
        // but since we only care about the relative values that is okay.
        images.sort(descending(i => Date.parse(i.CreationDate || '1970')));
        logging_1.debug(`Selected image '${images[0].ImageId}' created at '${images[0].CreationDate}'`);
        return images[0].ImageId;
    }
}
exports.AmiContextProviderPlugin = AmiContextProviderPlugin;
/**
 * Make a comparator that sorts in descending order given a sort key extractor
 */
function descending(valueOf) {
    return (a, b) => {
        return valueOf(b) - valueOf(a);
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW1pLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYW1pLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQ0EsZ0NBQTJDO0FBQzNDLHdDQUEwQztBQUcxQzs7R0FFRztBQUNILE1BQWEsd0JBQXdCO0lBQ25DLFlBQTZCLEdBQWdCO1FBQWhCLFFBQUcsR0FBSCxHQUFHLENBQWE7SUFDN0MsQ0FBQztJQUVNLEtBQUssQ0FBQyxRQUFRLENBQUMsSUFBaUU7UUFDckYsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUMzQixNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDO1FBRTdCLG1GQUFtRjtRQUNuRixpRkFBaUY7UUFDakYsZUFBSyxDQUFDLHdCQUF3QixPQUFPLElBQUksTUFBTSxFQUFFLENBQUMsQ0FBQztRQUNuRCxlQUFLLENBQUMsMEJBQTBCLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRXhELE1BQU0sR0FBRyxHQUFHLENBQUMsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ3BGLE1BQU0sUUFBUSxHQUFHLE1BQU0sR0FBRyxDQUFDLGNBQWMsQ0FBQztZQUN4QyxNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU07WUFDbkIsT0FBTyxFQUFFLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO2dCQUM1RCxJQUFJLEVBQUUsR0FBRztnQkFDVCxNQUFNLEVBQUUsTUFBTTthQUNmLENBQUMsQ0FBQztTQUNKLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUViLE1BQU0sTUFBTSxHQUFHLENBQUMsR0FBRyxRQUFRLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxPQUFPLEtBQUssU0FBUyxDQUFDLENBQUM7UUFFL0UsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUN2QixNQUFNLElBQUksS0FBSyxDQUFDLCtDQUErQyxDQUFDLENBQUM7U0FDbEU7UUFFRCw2QkFBNkI7UUFDN0IseUVBQXlFO1FBQ3pFLGlFQUFpRTtRQUNqRSxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLFlBQVksSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFbkUsZUFBSyxDQUFDLG1CQUFtQixNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxpQkFBaUIsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksR0FBRyxDQUFDLENBQUM7UUFDdEYsT0FBTyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBUSxDQUFDO0lBQzVCLENBQUM7Q0FDRjtBQXBDRCw0REFvQ0M7QUFFRDs7R0FFRztBQUNILFNBQVMsVUFBVSxDQUFJLE9BQXlCO0lBQzlDLE9BQU8sQ0FBQyxDQUFJLEVBQUUsQ0FBSSxFQUFFLEVBQUU7UUFDcEIsT0FBTyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2pDLENBQUMsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0IHsgTW9kZSwgU2RrUHJvdmlkZXIgfSBmcm9tICcuLi9hcGknO1xuaW1wb3J0IHsgZGVidWcsIHByaW50IH0gZnJvbSAnLi4vbG9nZ2luZyc7XG5pbXBvcnQgeyBDb250ZXh0UHJvdmlkZXJQbHVnaW4gfSBmcm9tICcuL3Byb3ZpZGVyJztcblxuLyoqXG4gKiBQbHVnaW4gdG8gc2VhcmNoIEFNSXMgZm9yIHRoZSBjdXJyZW50IGFjY291bnRcbiAqL1xuZXhwb3J0IGNsYXNzIEFtaUNvbnRleHRQcm92aWRlclBsdWdpbiBpbXBsZW1lbnRzIENvbnRleHRQcm92aWRlclBsdWdpbiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgYXdzOiBTZGtQcm92aWRlcikge1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldFZhbHVlKGFyZ3M6IGN4YXBpLkFtaUNvbnRleHRRdWVyeSAmIHsgcmVnaW9uOiBzdHJpbmcsIGFjY291bnQ6IHN0cmluZyB9KSB7XG4gICAgY29uc3QgcmVnaW9uID0gYXJncy5yZWdpb247XG4gICAgY29uc3QgYWNjb3VudCA9IGFyZ3MuYWNjb3VudDtcblxuICAgIC8vIE5vcm1hbGx5IHdlJ2QgZG8gdGhpcyBvbmx5IGFzICdkZWJ1ZycsIGJ1dCBzZWFyY2hpbmcgQU1JcyB0eXBpY2FsbHkgdGFrZXMgZG96ZW5zXG4gICAgLy8gb2Ygc2Vjb25kcywgc28gYmUgbGl0dGxlIG1vcmUgdmVyYm9zZSBhYm91dCBpdCBzbyB1c2VycyBrbm93IHdoYXQgaXMgZ29pbmcgb24uXG4gICAgcHJpbnQoYFNlYXJjaGluZyBmb3IgQU1JIGluICR7YWNjb3VudH06JHtyZWdpb259YCk7XG4gICAgZGVidWcoYEFNSSBzZWFyY2ggcGFyYW1ldGVyczogJHtKU09OLnN0cmluZ2lmeShhcmdzKX1gKTtcblxuICAgIGNvbnN0IGVjMiA9IChhd2FpdCB0aGlzLmF3cy5mb3JFbnZpcm9ubWVudChhY2NvdW50LCByZWdpb24sIE1vZGUuRm9yUmVhZGluZykpLmVjMigpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZWMyLmRlc2NyaWJlSW1hZ2VzKHtcbiAgICAgIE93bmVyczogYXJncy5vd25lcnMsXG4gICAgICBGaWx0ZXJzOiBPYmplY3QuZW50cmllcyhhcmdzLmZpbHRlcnMpLm1hcCgoW2tleSwgdmFsdWVzXSkgPT4gKHtcbiAgICAgICAgTmFtZToga2V5LFxuICAgICAgICBWYWx1ZXM6IHZhbHVlc1xuICAgICAgfSkpXG4gICAgfSkucHJvbWlzZSgpO1xuXG4gICAgY29uc3QgaW1hZ2VzID0gWy4uLnJlc3BvbnNlLkltYWdlcyB8fCBbXV0uZmlsdGVyKGkgPT4gaS5JbWFnZUlkICE9PSB1bmRlZmluZWQpO1xuXG4gICAgaWYgKGltYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gQU1JIGZvdW5kIHRoYXQgbWF0Y2hlZCB0aGUgc2VhcmNoIGNyaXRlcmlhJyk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRoZSBtb3N0IHJlY2VudCBvbmVcbiAgICAvLyBOb3RlOiBEYXRlLnBhcnNlKCkgaXMgbm90IGdvaW5nIHRvIHJlc3BlY3QgdGhlIHRpbWV6b25lIG9mIHRoZSBzdHJpbmcsXG4gICAgLy8gYnV0IHNpbmNlIHdlIG9ubHkgY2FyZSBhYm91dCB0aGUgcmVsYXRpdmUgdmFsdWVzIHRoYXQgaXMgb2theS5cbiAgICBpbWFnZXMuc29ydChkZXNjZW5kaW5nKGkgPT4gRGF0ZS5wYXJzZShpLkNyZWF0aW9uRGF0ZSB8fCAnMTk3MCcpKSk7XG5cbiAgICBkZWJ1ZyhgU2VsZWN0ZWQgaW1hZ2UgJyR7aW1hZ2VzWzBdLkltYWdlSWR9JyBjcmVhdGVkIGF0ICcke2ltYWdlc1swXS5DcmVhdGlvbkRhdGV9J2ApO1xuICAgIHJldHVybiBpbWFnZXNbMF0uSW1hZ2VJZCE7XG4gIH1cbn1cblxuLyoqXG4gKiBNYWtlIGEgY29tcGFyYXRvciB0aGF0IHNvcnRzIGluIGRlc2NlbmRpbmcgb3JkZXIgZ2l2ZW4gYSBzb3J0IGtleSBleHRyYWN0b3JcbiAqL1xuZnVuY3Rpb24gZGVzY2VuZGluZzxBPih2YWx1ZU9mOiAoeDogQSkgPT4gbnVtYmVyKSB7XG4gIHJldHVybiAoYTogQSwgYjogQSkgPT4ge1xuICAgIHJldHVybiB2YWx1ZU9mKGIpIC0gdmFsdWVPZihhKTtcbiAgfTtcbn1cbiJdfQ==