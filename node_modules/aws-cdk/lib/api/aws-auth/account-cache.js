"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const os = require("os");
const path = require("path");
const logging_1 = require("../../logging");
/**
 * Disk cache which maps access key IDs to account IDs.
 * Usage:
 *   cache.get(accessKey) => accountId | undefined
 *   cache.put(accessKey, accountId)
 */
class AccountAccessKeyCache {
    /**
     * @param filePath Path to the cache file
     */
    constructor(filePath) {
        this.cacheFile = filePath || path.join(os.homedir(), '.cdk', 'cache', 'accounts_partitions.json');
    }
    /**
     * Tries to fetch the account ID from cache. If it's not in the cache, invokes
     * the resolver function which should retrieve the account ID and return it.
     * Then, it will be stored into disk cache returned.
     *
     * Example:
     *
     *    const accountId = cache.fetch(accessKey, async () => {
     *      return await fetchAccountIdFromSomewhere(accessKey);
     *    });
     *
     * @param accessKeyId
     * @param resolver
     */
    async fetch(accessKeyId, resolver) {
        // try to get account ID based on this access key ID from disk.
        const cached = await this.get(accessKeyId);
        if (cached) {
            logging_1.debug(`Retrieved account ID ${cached.accountId} from disk cache`);
            return cached;
        }
        // if it's not in the cache, resolve and put in cache.
        const account = await resolver();
        if (account) {
            await this.put(accessKeyId, account);
        }
        return account;
    }
    /** Get the account ID from an access key or undefined if not in cache */
    async get(accessKeyId) {
        const map = await this.loadMap();
        return map[accessKeyId];
    }
    /** Put a mapping betweenn access key and account ID */
    async put(accessKeyId, account) {
        let map = await this.loadMap();
        // nuke cache if it's too big.
        if (Object.keys(map).length >= AccountAccessKeyCache.MAX_ENTRIES) {
            map = {};
        }
        map[accessKeyId] = account;
        await this.saveMap(map);
    }
    async loadMap() {
        if (!(await fs.pathExists(this.cacheFile))) {
            return {};
        }
        return await fs.readJson(this.cacheFile);
    }
    async saveMap(map) {
        if (!(await fs.pathExists(this.cacheFile))) {
            await fs.mkdirs(path.dirname(this.cacheFile));
        }
        await fs.writeJson(this.cacheFile, map, { spaces: 2 });
    }
}
exports.AccountAccessKeyCache = AccountAccessKeyCache;
/**
 * Max number of entries in the cache, after which the cache will be reset.
 */
AccountAccessKeyCache.MAX_ENTRIES = 1000;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWNjb3VudC1jYWNoZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImFjY291bnQtY2FjaGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwrQkFBK0I7QUFDL0IseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QiwyQ0FBc0M7QUFHdEM7Ozs7O0dBS0c7QUFDSCxNQUFhLHFCQUFxQjtJQVFoQzs7T0FFRztJQUNILFlBQVksUUFBaUI7UUFDM0IsSUFBSSxDQUFDLFNBQVMsR0FBRyxRQUFRLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSwwQkFBMEIsQ0FBQyxDQUFDO0lBQ3BHLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7OztPQWFHO0lBQ0ksS0FBSyxDQUFDLEtBQUssQ0FBb0IsV0FBbUIsRUFBRSxRQUEwQjtRQUNuRiwrREFBK0Q7UUFDL0QsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQzNDLElBQUksTUFBTSxFQUFFO1lBRVYsZUFBSyxDQUFDLHdCQUF3QixNQUFNLENBQUMsU0FBUyxrQkFBa0IsQ0FBQyxDQUFDO1lBQ2xFLE9BQU8sTUFBTSxDQUFDO1NBQ2Y7UUFFRCxzREFBc0Q7UUFDdEQsTUFBTSxPQUFPLEdBQUcsTUFBTSxRQUFRLEVBQUUsQ0FBQztRQUNqQyxJQUFJLE9BQU8sRUFBRTtZQUNYLE1BQU0sSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEVBQUUsT0FBTyxDQUFDLENBQUM7U0FDdEM7UUFFRCxPQUFPLE9BQU8sQ0FBQztJQUNqQixDQUFDO0lBRUQseUVBQXlFO0lBQ2xFLEtBQUssQ0FBQyxHQUFHLENBQUMsV0FBbUI7UUFDbEMsTUFBTSxHQUFHLEdBQUcsTUFBTSxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDakMsT0FBTyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDMUIsQ0FBQztJQUVELHVEQUF1RDtJQUNoRCxLQUFLLENBQUMsR0FBRyxDQUFDLFdBQW1CLEVBQUUsT0FBZ0I7UUFDcEQsSUFBSSxHQUFHLEdBQUcsTUFBTSxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7UUFFL0IsOEJBQThCO1FBQzlCLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLElBQUkscUJBQXFCLENBQUMsV0FBVyxFQUFFO1lBQ2hFLEdBQUcsR0FBRyxFQUFHLENBQUM7U0FDWDtRQUVELEdBQUcsQ0FBQyxXQUFXLENBQUMsR0FBRyxPQUFPLENBQUM7UUFDM0IsTUFBTSxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFFTyxLQUFLLENBQUMsT0FBTztRQUNuQixJQUFJLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUU7WUFDMUMsT0FBTyxFQUFHLENBQUM7U0FDWjtRQUVELE9BQU8sTUFBTSxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUMzQyxDQUFDO0lBRU8sS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUF1QztRQUMzRCxJQUFJLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUU7WUFDMUMsTUFBTSxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7U0FDL0M7UUFFRCxNQUFNLEVBQUUsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxHQUFHLEVBQUUsRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUN6RCxDQUFDOztBQWhGSCxzREFpRkM7QUFoRkM7O0dBRUc7QUFDb0IsaUNBQVcsR0FBRyxJQUFJLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgKiBhcyBvcyBmcm9tICdvcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgZGVidWcgfSBmcm9tICcuLi8uLi9sb2dnaW5nJztcbmltcG9ydCB7IEFjY291bnQgfSBmcm9tICcuL3Nkay1wcm92aWRlcic7XG5cbi8qKlxuICogRGlzayBjYWNoZSB3aGljaCBtYXBzIGFjY2VzcyBrZXkgSURzIHRvIGFjY291bnQgSURzLlxuICogVXNhZ2U6XG4gKiAgIGNhY2hlLmdldChhY2Nlc3NLZXkpID0+IGFjY291bnRJZCB8IHVuZGVmaW5lZFxuICogICBjYWNoZS5wdXQoYWNjZXNzS2V5LCBhY2NvdW50SWQpXG4gKi9cbmV4cG9ydCBjbGFzcyBBY2NvdW50QWNjZXNzS2V5Q2FjaGUge1xuICAvKipcbiAgICogTWF4IG51bWJlciBvZiBlbnRyaWVzIGluIHRoZSBjYWNoZSwgYWZ0ZXIgd2hpY2ggdGhlIGNhY2hlIHdpbGwgYmUgcmVzZXQuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IE1BWF9FTlRSSUVTID0gMTAwMDtcblxuICBwcml2YXRlIHJlYWRvbmx5IGNhY2hlRmlsZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gZmlsZVBhdGggUGF0aCB0byB0aGUgY2FjaGUgZmlsZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZmlsZVBhdGg/OiBzdHJpbmcpIHtcbiAgICB0aGlzLmNhY2hlRmlsZSA9IGZpbGVQYXRoIHx8IHBhdGguam9pbihvcy5ob21lZGlyKCksICcuY2RrJywgJ2NhY2hlJywgJ2FjY291bnRzX3BhcnRpdGlvbnMuanNvbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaWVzIHRvIGZldGNoIHRoZSBhY2NvdW50IElEIGZyb20gY2FjaGUuIElmIGl0J3Mgbm90IGluIHRoZSBjYWNoZSwgaW52b2tlc1xuICAgKiB0aGUgcmVzb2x2ZXIgZnVuY3Rpb24gd2hpY2ggc2hvdWxkIHJldHJpZXZlIHRoZSBhY2NvdW50IElEIGFuZCByZXR1cm4gaXQuXG4gICAqIFRoZW4sIGl0IHdpbGwgYmUgc3RvcmVkIGludG8gZGlzayBjYWNoZSByZXR1cm5lZC5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogICAgY29uc3QgYWNjb3VudElkID0gY2FjaGUuZmV0Y2goYWNjZXNzS2V5LCBhc3luYyAoKSA9PiB7XG4gICAqICAgICAgcmV0dXJuIGF3YWl0IGZldGNoQWNjb3VudElkRnJvbVNvbWV3aGVyZShhY2Nlc3NLZXkpO1xuICAgKiAgICB9KTtcbiAgICpcbiAgICogQHBhcmFtIGFjY2Vzc0tleUlkXG4gICAqIEBwYXJhbSByZXNvbHZlclxuICAgKi9cbiAgcHVibGljIGFzeW5jIGZldGNoPEEgZXh0ZW5kcyBBY2NvdW50PihhY2Nlc3NLZXlJZDogc3RyaW5nLCByZXNvbHZlcjogKCkgPT4gUHJvbWlzZTxBPikge1xuICAgIC8vIHRyeSB0byBnZXQgYWNjb3VudCBJRCBiYXNlZCBvbiB0aGlzIGFjY2VzcyBrZXkgSUQgZnJvbSBkaXNrLlxuICAgIGNvbnN0IGNhY2hlZCA9IGF3YWl0IHRoaXMuZ2V0KGFjY2Vzc0tleUlkKTtcbiAgICBpZiAoY2FjaGVkKSB7XG5cbiAgICAgIGRlYnVnKGBSZXRyaWV2ZWQgYWNjb3VudCBJRCAke2NhY2hlZC5hY2NvdW50SWR9IGZyb20gZGlzayBjYWNoZWApO1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG5cbiAgICAvLyBpZiBpdCdzIG5vdCBpbiB0aGUgY2FjaGUsIHJlc29sdmUgYW5kIHB1dCBpbiBjYWNoZS5cbiAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgcmVzb2x2ZXIoKTtcbiAgICBpZiAoYWNjb3VudCkge1xuICAgICAgYXdhaXQgdGhpcy5wdXQoYWNjZXNzS2V5SWQsIGFjY291bnQpO1xuICAgIH1cblxuICAgIHJldHVybiBhY2NvdW50O1xuICB9XG5cbiAgLyoqIEdldCB0aGUgYWNjb3VudCBJRCBmcm9tIGFuIGFjY2VzcyBrZXkgb3IgdW5kZWZpbmVkIGlmIG5vdCBpbiBjYWNoZSAqL1xuICBwdWJsaWMgYXN5bmMgZ2V0KGFjY2Vzc0tleUlkOiBzdHJpbmcpOiBQcm9taXNlPEFjY291bnQgfCB1bmRlZmluZWQ+IHtcbiAgICBjb25zdCBtYXAgPSBhd2FpdCB0aGlzLmxvYWRNYXAoKTtcbiAgICByZXR1cm4gbWFwW2FjY2Vzc0tleUlkXTtcbiAgfVxuXG4gIC8qKiBQdXQgYSBtYXBwaW5nIGJldHdlZW5uIGFjY2VzcyBrZXkgYW5kIGFjY291bnQgSUQgKi9cbiAgcHVibGljIGFzeW5jIHB1dChhY2Nlc3NLZXlJZDogc3RyaW5nLCBhY2NvdW50OiBBY2NvdW50KSB7XG4gICAgbGV0IG1hcCA9IGF3YWl0IHRoaXMubG9hZE1hcCgpO1xuXG4gICAgLy8gbnVrZSBjYWNoZSBpZiBpdCdzIHRvbyBiaWcuXG4gICAgaWYgKE9iamVjdC5rZXlzKG1hcCkubGVuZ3RoID49IEFjY291bnRBY2Nlc3NLZXlDYWNoZS5NQVhfRU5UUklFUykge1xuICAgICAgbWFwID0geyB9O1xuICAgIH1cblxuICAgIG1hcFthY2Nlc3NLZXlJZF0gPSBhY2NvdW50O1xuICAgIGF3YWl0IHRoaXMuc2F2ZU1hcChtYXApO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBsb2FkTWFwKCk6IFByb21pc2U8eyBbYWNjZXNzS2V5SWQ6IHN0cmluZ106IEFjY291bnQgfT4ge1xuICAgIGlmICghKGF3YWl0IGZzLnBhdGhFeGlzdHModGhpcy5jYWNoZUZpbGUpKSkge1xuICAgICAgcmV0dXJuIHsgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgZnMucmVhZEpzb24odGhpcy5jYWNoZUZpbGUpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBzYXZlTWFwKG1hcDogeyBbYWNjZXNzS2V5SWQ6IHN0cmluZ106IEFjY291bnQgfSkge1xuICAgIGlmICghKGF3YWl0IGZzLnBhdGhFeGlzdHModGhpcy5jYWNoZUZpbGUpKSkge1xuICAgICAgYXdhaXQgZnMubWtkaXJzKHBhdGguZGlybmFtZSh0aGlzLmNhY2hlRmlsZSkpO1xuICAgIH1cblxuICAgIGF3YWl0IGZzLndyaXRlSnNvbih0aGlzLmNhY2hlRmlsZSwgbWFwLCB7IHNwYWNlczogMiB9KTtcbiAgfVxufVxuIl19