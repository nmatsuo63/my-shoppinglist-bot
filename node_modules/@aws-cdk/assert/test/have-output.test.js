"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cxschema = require("@aws-cdk/cloud-assembly-schema");
const cxapi = require("@aws-cdk/cx-api");
const fs_1 = require("fs");
const path_1 = require("path");
require("../jest");
let templateFilePath;
let synthStack;
let noOutputStack;
beforeEach(done => {
    synthStack = mkStack({
        Resources: {
            SomeResource: {
                Type: 'Some::Resource',
                Properties: {
                    PropA: 'somevalue'
                }
            },
            AnotherResource: {
                Type: 'Some::AnotherResource',
                Properties: {
                    PropA: 'anothervalue'
                }
            }
        },
        Outputs: {
            TestOutput: {
                Value: {
                    'Fn::GetAtt': [
                        'SomeResource',
                        'Arn'
                    ]
                },
                Export: {
                    Name: 'TestOutputExportName'
                }
            },
            ComplexExportNameOutput: {
                Value: {
                    'Fn::GetAtt': [
                        'ComplexOutputResource',
                        'Arn'
                    ]
                },
                Export: {
                    Name: {
                        'Fn::Sub': '${AWS::StackName}-ComplexExportNameOutput'
                    }
                }
            }
        }
    });
    noOutputStack = mkStack({
        Resources: {
            SomeResource: {
                Type: 'Some::Resource',
                Properties: {
                    PropA: 'somevalue'
                }
            }
        }
    });
    done();
});
test('haveOutput should assert true when output with correct name is provided', () => {
    expect(synthStack).toHaveOutput({
        outputName: 'TestOutput'
    });
});
test('haveOutput should assert false when output with incorrect name is provided', () => {
    expect(synthStack).not.toHaveOutput({
        outputName: 'WrongOutput'
    });
});
test('haveOutput should assert true when output with correct name and export name is provided', () => {
    expect(synthStack).toHaveOutput({
        outputName: 'TestOutput',
        exportName: 'TestOutputExportName',
    });
});
test('haveOutput should assert false when output with correct name and incorrect export name is provided', () => {
    expect(synthStack).not.toHaveOutput({
        outputName: 'TestOutput',
        exportName: 'WrongTestOutputExportName',
    });
});
test('haveOutput should assert true when output with correct name, export name and value is provided', () => {
    expect(synthStack).toHaveOutput({
        outputName: 'TestOutput',
        exportName: 'TestOutputExportName',
        outputValue: {
            'Fn::GetAtt': [
                'SomeResource',
                'Arn'
            ]
        }
    });
});
test('haveOutput should assert false when output with correct name and export name and incorrect value is provided', () => {
    expect(synthStack).not.toHaveOutput({
        outputName: 'TestOutput',
        exportName: 'TestOutputExportName',
        outputValue: 'SomeWrongValue'
    });
});
test('haveOutput should assert true when output with correct export name and value is provided', () => {
    expect(synthStack).toHaveOutput({
        exportName: 'TestOutputExportName',
        outputValue: {
            'Fn::GetAtt': [
                'SomeResource',
                'Arn'
            ]
        }
    });
});
test('haveOutput should assert false when output with correct export name and incorrect value is provided', () => {
    expect(synthStack).not.toHaveOutput({
        exportName: 'TestOutputExportName',
        outputValue: 'WrongValue'
    });
});
test('haveOutput should assert true when output with correct output name and value is provided', () => {
    expect(synthStack).toHaveOutput({
        outputName: 'TestOutput',
        outputValue: {
            'Fn::GetAtt': [
                'SomeResource',
                'Arn'
            ]
        }
    });
});
test('haveOutput should assert false when output with correct output name and incorrect value is provided', () => {
    expect(synthStack).not.toHaveOutput({
        outputName: 'TestOutput',
        outputValue: 'WrongValue'
    });
});
test('haveOutput should assert false when asserting against noOutputStack', () => {
    expect(noOutputStack).not.toHaveOutput({
        outputName: 'TestOutputName',
        exportName: 'TestExportName',
        outputValue: 'TestOutputValue'
    });
});
test('haveOutput should throw Error when none of outputName and exportName is provided', () => {
    expect(() => expect(synthStack).toHaveOutput({ outputValue: 'SomeValue' }))
        .toThrow('At least one of [outputName, exportName] should be provided');
});
test('haveOutput should be able to handle complex exportName values', () => {
    expect(synthStack).toHaveOutput({
        exportName: { 'Fn::Sub': '${AWS::StackName}-ComplexExportNameOutput' },
        outputValue: {
            'Fn::GetAtt': [
                'ComplexOutputResource',
                'Arn'
            ]
        }
    });
});
afterEach(done => {
    if (templateFilePath) {
        fs_1.unlink(templateFilePath, done);
    }
    else {
        done();
    }
});
function mkStack(template) {
    const templateFileName = 'test-have-output-template.json';
    const stackName = 'test-have-output';
    const assembly = new cxapi.CloudAssemblyBuilder();
    assembly.addArtifact(stackName, {
        type: cxschema.ArtifactType.AWS_CLOUDFORMATION_STACK,
        environment: cxapi.EnvironmentUtils.format('123456789012', 'bermuda-triangle-1'),
        properties: {
            templateFile: templateFileName
        }
    });
    templateFilePath = path_1.join(assembly.outdir, templateFileName);
    fs_1.writeFileSync(templateFilePath, JSON.stringify(template));
    return assembly.buildAssembly().getStackByName(stackName);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGF2ZS1vdXRwdXQudGVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImhhdmUtb3V0cHV0LnRlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwyREFBMkQ7QUFDM0QseUNBQXlDO0FBQ3pDLDJCQUEyQztBQUMzQywrQkFBNEI7QUFDNUIsbUJBQWlCO0FBRWpCLElBQUksZ0JBQXdCLENBQUM7QUFDN0IsSUFBSSxVQUE2QyxDQUFDO0FBQ2xELElBQUksYUFBZ0QsQ0FBQztBQUVyRCxVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUU7SUFDaEIsVUFBVSxHQUFHLE9BQU8sQ0FBQztRQUNuQixTQUFTLEVBQUU7WUFDVCxZQUFZLEVBQUU7Z0JBQ1osSUFBSSxFQUFFLGdCQUFnQjtnQkFDdEIsVUFBVSxFQUFFO29CQUNWLEtBQUssRUFBRSxXQUFXO2lCQUNuQjthQUNGO1lBQ0QsZUFBZSxFQUFFO2dCQUNmLElBQUksRUFBRSx1QkFBdUI7Z0JBQzdCLFVBQVUsRUFBRTtvQkFDVixLQUFLLEVBQUUsY0FBYztpQkFDdEI7YUFDRjtTQUNGO1FBQ0QsT0FBTyxFQUFFO1lBQ1AsVUFBVSxFQUFFO2dCQUNWLEtBQUssRUFBRTtvQkFDTCxZQUFZLEVBQUU7d0JBQ1osY0FBYzt3QkFDZCxLQUFLO3FCQUNOO2lCQUNGO2dCQUNELE1BQU0sRUFBRTtvQkFDTixJQUFJLEVBQUUsc0JBQXNCO2lCQUM3QjthQUNGO1lBQ0QsdUJBQXVCLEVBQUU7Z0JBQ3ZCLEtBQUssRUFBRTtvQkFDTCxZQUFZLEVBQUU7d0JBQ1osdUJBQXVCO3dCQUN2QixLQUFLO3FCQUNOO2lCQUNGO2dCQUNELE1BQU0sRUFBRTtvQkFDTixJQUFJLEVBQUU7d0JBQ0osU0FBUyxFQUFFLDJDQUEyQztxQkFDdkQ7aUJBQ0Y7YUFDRjtTQUNGO0tBQ0YsQ0FBQyxDQUFDO0lBQ0gsYUFBYSxHQUFHLE9BQU8sQ0FBQztRQUN0QixTQUFTLEVBQUU7WUFDVCxZQUFZLEVBQUU7Z0JBQ1osSUFBSSxFQUFF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QUFHLGtCQUFrQixDQUFDO0lBQ3JDLE1BQU0sUUFBUSxHQUFHLElBQUksS0FBSyxDQUFDLG9CQUFvQixFQUFFLENBQUM7SUFFbEQsUUFBUSxDQUFDLFdBQVcsQ0FBQyxTQUFTLEVBQUU7UUFDOUIsSUFBSSxFQUFFLFFBQVEsQ0FBQyxZQUFZLENBQUMsd0JBQXdCO1FBQ3BELFdBQVcsRUFBRSxLQUFLLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLGNBQWMsRUFBRSxvQkFBb0IsQ0FBQztRQUNoRixVQUFVLEVBQUU7WUFDVixZQUFZLEVBQUUsZ0JBQWdCO1NBQy9CO0tBQ0YsQ0FBQyxDQUFDO0lBRUgsZ0JBQWdCLEdBQUcsV0FBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztJQUMzRCxrQkFBYSxDQUFDLGdCQUFnQixFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztJQUUxRCxPQUFPLFFBQVEsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDNUQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGN4c2NoZW1hIGZyb20gJ0Bhd3MtY2RrL2Nsb3VkLWFzc2VtYmx5LXNjaGVtYSc7XG5pbXBvcnQgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0IHsgdW5saW5rLCB3cml0ZUZpbGVTeW5jIH0gZnJvbSAnZnMnO1xuaW1wb3J0IHsgam9pbiB9IGZyb20gJ3BhdGgnO1xuaW1wb3J0ICcuLi9qZXN0JztcblxubGV0IHRlbXBsYXRlRmlsZVBhdGg6IHN0cmluZztcbmxldCBzeW50aFN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3Q7XG5sZXQgbm9PdXRwdXRTdGFjazogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0O1xuXG5iZWZvcmVFYWNoKGRvbmUgPT4ge1xuICBzeW50aFN0YWNrID0gbWtTdGFjayh7XG4gICAgUmVzb3VyY2VzOiB7XG4gICAgICBTb21lUmVzb3VyY2U6IHtcbiAgICAgICAgVHlwZTogJ1NvbWU6OlJlc291cmNlJyxcbiAgICAgICAgUHJvcGVydGllczoge1xuICAgICAgICAgIFByb3BBOiAnc29tZXZhbHVlJ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgQW5vdGhlclJlc291cmNlOiB7XG4gICAgICAgIFR5cGU6ICdTb21lOjpBbm90aGVyUmVzb3VyY2UnLFxuICAgICAgICBQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgUHJvcEE6ICdhbm90aGVydmFsdWUnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIE91dHB1dHM6IHtcbiAgICAgIFRlc3RPdXRwdXQ6IHtcbiAgICAgICAgVmFsdWU6IHtcbiAgICAgICAgICAnRm46OkdldEF0dCc6IFtcbiAgICAgICAgICAgICdTb21lUmVzb3VyY2UnLFxuICAgICAgICAgICAgJ0FybidcbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIEV4cG9ydDoge1xuICAgICAgICAgIE5hbWU6ICdUZXN0T3V0cHV0RXhwb3J0TmFtZSdcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIENvbXBsZXhFeHBvcnROYW1lT3V0cHV0OiB7XG4gICAgICAgIFZhbHVlOiB7XG4gICAgICAgICAgJ0ZuOjpHZXRBdHQnOiBbXG4gICAgICAgICAgICAnQ29tcGxleE91dHB1dFJlc291cmNlJyxcbiAgICAgICAgICAgICdBcm4nXG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBFeHBvcnQ6IHtcbiAgICAgICAgICBOYW1lOiB7XG4gICAgICAgICAgICAnRm46OlN1Yic6ICcke0FXUzo6U3RhY2tOYW1lfS1Db21wbGV4RXhwb3J0TmFtZU91dHB1dCdcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBub091dHB1dFN0YWNrID0gbWtTdGFjayh7XG4gICAgUmVzb3VyY2VzOiB7XG4gICAgICBTb21lUmVzb3VyY2U6IHtcbiAgICAgICAgVHlwZTogJ1NvbWU6OlJlc291cmNlJyxcbiAgICAgICAgUHJvcGVydGllczoge1xuICAgICAgICAgIFByb3BBOiAnc29tZXZhbHVlJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgZG9uZSgpO1xufSk7XG5cbnRlc3QoJ2hhdmVPdXRwdXQgc2hvdWxkIGFzc2VydCB0cnVlIHdoZW4gb3V0cHV0IHdpdGggY29ycmVjdCBuYW1lIGlzIHByb3ZpZGVkJywgKCkgPT4ge1xuICBleHBlY3Qoc3ludGhTdGFjaykudG9IYXZlT3V0cHV0KHtcbiAgICBvdXRwdXROYW1lOiAnVGVzdE91dHB1dCdcbiAgfSk7XG59KTtcblxudGVzdCgnaGF2ZU91dHB1dCBzaG91bGQgYXNzZXJ0IGZhbHNlIHdoZW4gb3V0cHV0IHdpdGggaW5jb3JyZWN0IG5hbWUgaXMgcHJvdmlkZWQnLCAoKSA9PiB7XG4gIGV4cGVjdChzeW50aFN0YWNrKS5ub3QudG9IYXZlT3V0cHV0KHtcbiAgICBvdXRwdXROYW1lOiAnV3JvbmdPdXRwdXQnXG4gIH0pO1xufSk7XG5cbnRlc3QoJ2hhdmVPdXRwdXQgc2hvdWxkIGFzc2VydCB0cnVlIHdoZW4gb3V0cHV0IHdpdGggY29ycmVjdCBuYW1lIGFuZCBleHBvcnQgbmFtZSBpcyBwcm92aWRlZCcsICgpID0+IHtcbiAgZXhwZWN0KHN5bnRoU3RhY2spLnRvSGF2ZU91dHB1dCh7XG4gICAgb3V0cHV0TmFtZTogJ1Rlc3RPdXRwdXQnLFxuICAgIGV4cG9ydE5hbWU6ICdUZXN0T3V0cHV0RXhwb3J0TmFtZScsXG4gIH0pO1xufSk7XG5cbnRlc3QoJ2hhdmVPdXRwdXQgc2hvdWxkIGFzc2VydCBmYWxzZSB3aGVuIG91dHB1dCB3aXRoIGNvcnJlY3QgbmFtZSBhbmQgaW5jb3JyZWN0IGV4cG9ydCBuYW1lIGlzIHByb3ZpZGVkJywgKCkgPT4ge1xuICBleHBlY3Qoc3ludGhTdGFjaykubm90LnRvSGF2ZU91dHB1dCh7XG4gICAgb3V0cHV0TmFtZTogJ1Rlc3RPdXRwdXQnLFxuICAgIGV4cG9ydE5hbWU6ICdXcm9uZ1Rlc3RPdXRwdXRFeHBvcnROYW1lJyxcbiAgfSk7XG59KTtcblxudGVzdCgnaGF2ZU91dHB1dCBzaG91bGQgYXNzZXJ0IHRydWUgd2hlbiBvdXRwdXQgd2l0aCBjb3JyZWN0IG5hbWUsIGV4cG9ydCBuYW1lIGFuZCB2YWx1ZSBpcyBwcm92aWRlZCcsICgpID0+IHtcbiAgZXhwZWN0KHN5bnRoU3RhY2spLnRvSGF2ZU91dHB1dCh7XG4gICAgb3V0cHV0TmFtZTogJ1Rlc3RPdXRwdXQnLFxuICAgIGV4cG9ydE5hbWU6ICdUZXN0T3V0cHV0RXhwb3J0TmFtZScsXG4gICAgb3V0cHV0VmFsdWU6IHtcbiAgICAgICdGbjo6R2V0QXR0JzogW1xuICAgICAgICAnU29tZVJlc291cmNlJyxcbiAgICAgICAgJ0FybidcbiAgICAgIF1cbiAgICB9XG4gIH0pO1xufSk7XG5cbnRlc3QoJ2hhdmVPdXRwdXQgc2hvdWxkIGFzc2VydCBmYWxzZSB3aGVuIG91dHB1dCB3aXRoIGNvcnJlY3QgbmFtZSBhbmQgZXhwb3J0IG5hbWUgYW5kIGluY29ycmVjdCB2YWx1ZSBpcyBwcm92aWRlZCcsICgpID0+IHtcbiAgZXhwZWN0KHN5bnRoU3RhY2spLm5vdC50b0hhdmVPdXRwdXQoe1xuICAgIG91dHB1dE5hbWU6ICdUZXN0T3V0cHV0JyxcbiAgICBleHBvcnROYW1lOiAnVGVzdE91dHB1dEV4cG9ydE5hbWUnLFxuICAgIG91dHB1dFZhbHVlOiAnU29tZVdyb25nVmFsdWUnXG4gIH0pO1xufSk7XG5cbnRlc3QoJ2hhdmVPdXRwdXQgc2hvdWxkIGFzc2VydCB0cnVlIHdoZW4gb3V0cHV0IHdpdGggY29ycmVjdCBleHBvcnQgbmFtZSBhbmQgdmFsdWUgaXMgcHJvdmlkZWQnLCAoKSA9PiB7XG4gIGV4cGVjdChzeW50aFN0YWNrKS50b0hhdmVPdXRwdXQoe1xuICAgIGV4cG9ydE5hbWU6ICdUZXN0T3V0cHV0RXhwb3J0TmFtZScsXG4gICAgb3V0cHV0VmFsdWU6IHtcbiAgICAgICdGbjo6R2V0QXR0JzogW1xuICAgICAgICAnU29tZVJlc291cmNlJyxcbiAgICAgICAgJ0FybidcbiAgICAgIF1cbiAgICB9XG4gIH0pO1xufSk7XG5cbnRlc3QoJ2hhdmVPdXRwdXQgc2hvdWxkIGFzc2VydCBmYWxzZSB3aGVuIG91dHB1dCB3aXRoIGNvcnJlY3QgZXhwb3J0IG5hbWUgYW5kIGluY29ycmVjdCB2YWx1ZSBpcyBwcm92aWRlZCcsICgpID0+IHtcbiAgZXhwZWN0KHN5bnRoU3RhY2spLm5vdC50b0hhdmVPdXRwdXQoe1xuICAgIGV4cG9ydE5hbWU6ICdUZXN0T3V0cHV0RXhwb3J0TmFtZScsXG4gICAgb3V0cHV0VmFsdWU6ICdXcm9uZ1ZhbHVlJ1xuICB9KTtcbn0pO1xuXG50ZXN0KCdoYXZlT3V0cHV0IHNob3VsZCBhc3NlcnQgdHJ1ZSB3aGVuIG91dHB1dCB3aXRoIGNvcnJlY3Qgb3V0cHV0IG5hbWUgYW5kIHZhbHVlIGlzIHByb3ZpZGVkJywgKCkgPT4ge1xuICBleHBlY3Qoc3ludGhTdGFjaykudG9IYXZlT3V0cHV0KHtcbiAgICBvdXRwdXROYW1lOiAnVGVzdE91dHB1dCcsXG4gICAgb3V0cHV0VmFsdWU6IHtcbiAgICAgICdGbjo6R2V0QXR0JzogW1xuICAgICAgICAnU29tZVJlc291cmNlJyxcbiAgICAgICAgJ0FybidcbiAgICAgIF1cbiAgICB9XG4gIH0pO1xufSk7XG5cbnRlc3QoJ2hhdmVPdXRwdXQgc2hvdWxkIGFzc2VydCBmYWxzZSB3aGVuIG91dHB1dCB3aXRoIGNvcnJlY3Qgb3V0cHV0IG5hbWUgYW5kIGluY29ycmVjdCB2YWx1ZSBpcyBwcm92aWRlZCcsICgpID0+IHtcbiAgZXhwZWN0KHN5bnRoU3RhY2spLm5vdC50b0hhdmVPdXRwdXQoe1xuICAgIG91dHB1dE5hbWU6ICdUZXN0T3V0cHV0JyxcbiAgICBvdXRwdXRWYWx1ZTogJ1dyb25nVmFsdWUnXG4gIH0pO1xufSk7XG5cbnRlc3QoJ2hhdmVPdXRwdXQgc2hvdWxkIGFzc2VydCBmYWxzZSB3aGVuIGFzc2VydGluZyBhZ2FpbnN0IG5vT3V0cHV0U3RhY2snLCAoKSA9PiB7XG4gIGV4cGVjdChub091dHB1dFN0YWNrKS5ub3QudG9IYXZlT3V0cHV0KHtcbiAgICBvdXRwdXROYW1lOiAnVGVzdE91dHB1dE5hbWUnLFxuICAgIGV4cG9ydE5hbWU6ICdUZXN0RXhwb3J0TmFtZScsXG4gICAgb3V0cHV0VmFsdWU6ICdUZXN0T3V0cHV0VmFsdWUnXG4gIH0pO1xufSk7XG5cbnRlc3QoJ2hhdmVPdXRwdXQgc2hvdWxkIHRocm93IEVycm9yIHdoZW4gbm9uZSBvZiBvdXRwdXROYW1lIGFuZCBleHBvcnROYW1lIGlzIHByb3ZpZGVkJywgKCkgPT4ge1xuICBleHBlY3QoKCkgPT4gZXhwZWN0KHN5bnRoU3RhY2spLnRvSGF2ZU91dHB1dCh7IG91dHB1dFZhbHVlOiAnU29tZVZhbHVlJyB9KSlcbiAgICAudG9UaHJvdygnQXQgbGVhc3Qgb25lIG9mIFtvdXRwdXROYW1lLCBleHBvcnROYW1lXSBzaG91bGQgYmUgcHJvdmlkZWQnKTtcbn0pO1xuXG50ZXN0KCdoYXZlT3V0cHV0IHNob3VsZCBiZSBhYmxlIHRvIGhhbmRsZSBjb21wbGV4IGV4cG9ydE5hbWUgdmFsdWVzJywgKCkgPT4ge1xuICBleHBlY3Qoc3ludGhTdGFjaykudG9IYXZlT3V0cHV0KHtcbiAgICBleHBvcnROYW1lOiB7J0ZuOjpTdWInOiAnJHtBV1M6OlN0YWNrTmFtZX0tQ29tcGxleEV4cG9ydE5hbWVPdXRwdXQnfSxcbiAgICBvdXRwdXRWYWx1ZToge1xuICAgICAgJ0ZuOjpHZXRBdHQnOiBbXG4gICAgICAgICdDb21wbGV4T3V0cHV0UmVzb3VyY2UnLFxuICAgICAgICAnQXJuJ1xuICAgICAgXVxuICAgIH1cbiAgfSk7XG59KTtcblxuYWZ0ZXJFYWNoKGRvbmUgPT4ge1xuICBpZiAodGVtcGxhdGVGaWxlUGF0aCkge1xuICAgIHVubGluayh0ZW1wbGF0ZUZpbGVQYXRoLCBkb25lKTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKCk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBta1N0YWNrKHRlbXBsYXRlOiBhbnkpOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3Qge1xuICBjb25zdCB0ZW1wbGF0ZUZpbGVOYW1lID0gJ3Rlc3QtaGF2ZS1vdXRwdXQtdGVtcGxhdGUuanNvbic7XG4gIGNvbnN0IHN0YWNrTmFtZSA9ICd0ZXN0LWhhdmUtb3V0cHV0JztcbiAgY29uc3QgYXNzZW1ibHkgPSBuZXcgY3hhcGkuQ2xvdWRBc3NlbWJseUJ1aWxkZXIoKTtcblxuICBhc3NlbWJseS5hZGRBcnRpZmFjdChzdGFja05hbWUsIHtcbiAgICB0eXBlOiBjeHNjaGVtYS5BcnRpZmFjdFR5cGUuQVdTX0NMT1VERk9STUFUSU9OX1NUQUNLLFxuICAgIGVudmlyb25tZW50OiBjeGFwaS5FbnZpcm9ubWVudFV0aWxzLmZvcm1hdCgnMTIzNDU2Nzg5MDEyJywgJ2Jlcm11ZGEtdHJpYW5nbGUtMScpLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIHRlbXBsYXRlRmlsZTogdGVtcGxhdGVGaWxlTmFtZVxuICAgIH1cbiAgfSk7XG5cbiAgdGVtcGxhdGVGaWxlUGF0aCA9IGpvaW4oYXNzZW1ibHkub3V0ZGlyLCB0ZW1wbGF0ZUZpbGVOYW1lKTtcbiAgd3JpdGVGaWxlU3luYyh0ZW1wbGF0ZUZpbGVQYXRoLCBKU09OLnN0cmluZ2lmeSh0ZW1wbGF0ZSkpO1xuXG4gIHJldHVybiBhc3NlbWJseS5idWlsZEFzc2VtYmx5KCkuZ2V0U3RhY2tCeU5hbWUoc3RhY2tOYW1lKTtcbn1cbiJdfQ==