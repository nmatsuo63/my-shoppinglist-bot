"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const os = require("os");
const path = require("path");
const semver = require("semver");
const lib_1 = require("../lib");
const FIXTURES = path.join(__dirname, 'fixtures');
function fixture(name) {
    return path.join(FIXTURES, name, 'manifest.json');
}
function clone(obj) {
    return JSON.parse(JSON.stringify(obj));
}
function removeStringKeys(obj, keys) {
    function _recurse(o) {
        for (const prop in o) {
            if (keys.includes(prop) && typeof o[prop] === 'string') {
                delete o[prop];
            }
            else if (typeof o[prop] === 'object') {
                _recurse(o[prop]);
            }
        }
    }
    const cloned = clone(obj);
    _recurse(cloned);
    return cloned;
}
test('manifest save', () => {
    const outdir = fs.mkdtempSync(path.join(os.tmpdir(), 'schema-tests'));
    const manifestFile = path.join(outdir, 'manifest.json');
    const assemblyManifest = {
        version: 'version'
    };
    lib_1.Manifest.save(assemblyManifest, manifestFile);
    const saved = JSON.parse(fs.readFileSync(manifestFile, 'UTF-8'));
    expect(saved).toEqual(assemblyManifest);
});
test('cloud-assembly.json.schema is correct', () => {
    // when we compare schemas we ignore changes the
    // description that is generated from the ts docstrings.
    const docStringFields = [
        'description'
    ];
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const schema = require('../scripts/update-schema.js');
    const expected = removeStringKeys(schema.generate(), docStringFields);
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const actual = removeStringKeys(require('../schema/cloud-assembly.schema.json'), docStringFields);
    try {
        expect(actual).toEqual(expected);
    }
    catch (err) {
        // I couldn't for the life of me figure out how to provide additional error message
        // to jest...any ideas?
        err.message = `Whoops, Looks like the schema has changed. Did you forget to run 'yarn update-schema'?\n\n${err.message}`;
        throw err;
    }
});
test('manifest load', () => {
    const loaded = lib_1.Manifest.load(fixture('only-version'));
    expect(loaded).toMatchSnapshot();
});
test('manifest load fails for invalid nested property', () => {
    expect(() => lib_1.Manifest.load(fixture('invalid-nested-property'))).toThrow(/Invalid assembly manifest/);
});
test('manifest load fails for invalid artifact type', () => {
    expect(() => lib_1.Manifest.load(fixture('invalid-artifact-type'))).toThrow(/Invalid assembly manifest/);
});
test('manifest load fails on higher major version', () => {
    expect(() => lib_1.Manifest.load(fixture('high-version'))).toThrow(/Cloud assembly schema version mismatch/);
});
// once we start introducing minor version bumps that are considered
// non breaking, this test can be removed.
test('manifest load fails on higher minor version', () => {
    const outdir = fs.mkdtempSync(path.join(os.tmpdir(), 'schema-tests'));
    const manifestFile = path.join(outdir, 'manifest.json');
    const newVersion = semver.inc(lib_1.Manifest.version(), 'minor');
    expect(newVersion).toBeTruthy();
    if (newVersion) {
        const assemblyManifest = {
            version: newVersion
        };
        lib_1.Manifest.save(assemblyManifest, manifestFile);
        expect(() => lib_1.Manifest.load(manifestFile)).toThrow(/Cloud assembly schema version mismatch/);
    }
});
// once we start introducing patch version bumps that are considered
// non breaking, this test can be removed.
test('manifest load fails on higher patch version', () => {
    const outdir = fs.mkdtempSync(path.join(os.tmpdir(), 'schema-tests'));
    const manifestFile = path.join(outdir, 'manifest.json');
    const newVersion = semver.inc(lib_1.Manifest.version(), 'patch');
    expect(newVersion).toBeTruthy();
    if (newVersion) {
        const assemblyManifest = {
            version: newVersion
        };
        lib_1.Manifest.save(assemblyManifest, manifestFile);
        expect(() => lib_1.Manifest.load(manifestFile)).toThrow(/Cloud assembly schema version mismatch/);
    }
});
test('manifest load fails on invalid version', () => {
    expect(() => lib_1.Manifest.load(fixture('invalid-version'))).toThrow(/Invalid semver string/);
});
test('manifest load succeeds on unknown properties', () => {
    const manifest = lib_1.Manifest.load(fixture('unknown-property'));
    expect(manifest.version).toEqual('0.0.0');
});
test('stack-tags are deserialized properly', () => {
    var _a, _b, _c;
    const m = lib_1.Manifest.load(fixture('with-stack-tags'));
    if ((_c = (_b = (_a = m.artifacts) === null || _a === void 0 ? void 0 : _a.stack) === null || _b === void 0 ? void 0 : _b.metadata) === null || _c === void 0 ? void 0 : _c.AwsCdkPlaygroundBatch[0].data) {
        const entry = m.artifacts.stack.metadata.AwsCdkPlaygroundBatch[0].data;
        expect(entry[0].key).toEqual('hello');
        expect(entry[0].value).toEqual('world');
    }
    expect(m.version).toEqual('0.0.0');
});
test('can access random metadata', () => {
    var _a, _b, _c, _d, _e, _f;
    const loaded = lib_1.Manifest.load(fixture('random-metadata'));
    const randomArray = (_b = (_a = loaded.artifacts) === null || _a === void 0 ? void 0 : _a.stack.metadata) === null || _b === void 0 ? void 0 : _b.AwsCdkPlaygroundBatch[0].data;
    const randomNumber = (_d = (_c = loaded.artifacts) === null || _c === void 0 ? void 0 : _c.stack.metadata) === null || _d === void 0 ? void 0 : _d.AwsCdkPlaygroundBatch[1].data;
    const randomMap = (_f = (_e = loaded.artifacts) === null || _e === void 0 ? void 0 : _e.stack.metadata) === null || _f === void 0 ? void 0 : _f.AwsCdkPlaygroundBatch[2].data;
    expect(randomArray).toEqual(['42']);
    expect(randomNumber).toEqual(42);
    expect(randomMap).toEqual({
        key: 'value'
    });
    expect(randomMap).toBeTruthy();
    if (randomMap) {
        expect(randomMap.key).toEqual('value');
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFuaWZlc3QudGVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm1hbmlmZXN0LnRlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QixpQ0FBaUM7QUFDakMsZ0NBQTRFO0FBRTVFLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLFVBQVUsQ0FBQyxDQUFDO0FBRWxELFNBQVMsT0FBTyxDQUFDLElBQVk7SUFDM0IsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLEVBQUUsZUFBZSxDQUFDLENBQUM7QUFDcEQsQ0FBQztBQUVELFNBQVMsS0FBSyxDQUFDLEdBQVE7SUFDckIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUN6QyxDQUFDO0FBRUQsU0FBUyxnQkFBZ0IsQ0FBQyxHQUFRLEVBQUUsSUFBYztJQUVoRCxTQUFTLFFBQVEsQ0FBQyxDQUFNO1FBQ3RCLEtBQUssTUFBTSxJQUFJLElBQUksQ0FBQyxFQUFFO1lBQ3BCLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxRQUFRLEVBQUU7Z0JBQ3RELE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ2hCO2lCQUFNLElBQUksT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssUUFBUSxFQUFFO2dCQUN0QyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7YUFDbkI7U0FDRjtJQUNILENBQUM7SUFFRCxNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDMUIsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBRWpCLE9BQU8sTUFBTSxDQUFDO0FBRWhC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QUMsVUFBVSxFQUFFLENBQUM7SUFFL0IsSUFBSSxTQUFTLEVBQUU7UUFDYixNQUFNLENBQUUsU0FBaUIsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7S0FDakQ7QUFFSCxDQUFDLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIG9zIGZyb20gJ29zJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyBzZW12ZXIgZnJvbSAnc2VtdmVyJztcbmltcG9ydCB7IEFzc2VtYmx5TWFuaWZlc3QsIE1hbmlmZXN0LCBTdGFja1RhZ3NNZXRhZGF0YUVudHJ5IH0gZnJvbSAnLi4vbGliJztcblxuY29uc3QgRklYVFVSRVMgPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAnZml4dHVyZXMnKTtcblxuZnVuY3Rpb24gZml4dHVyZShuYW1lOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHBhdGguam9pbihGSVhUVVJFUywgbmFtZSwgJ21hbmlmZXN0Lmpzb24nKTtcbn1cblxuZnVuY3Rpb24gY2xvbmUob2JqOiBhbnkpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0cmluZ0tleXMob2JqOiBhbnksIGtleXM6IHN0cmluZ1tdKSB7XG5cbiAgZnVuY3Rpb24gX3JlY3Vyc2UobzogYW55KSB7XG4gICAgZm9yIChjb25zdCBwcm9wIGluIG8pIHtcbiAgICAgIGlmIChrZXlzLmluY2x1ZGVzKHByb3ApICYmIHR5cGVvZiBvW3Byb3BdID09PSAnc3RyaW5nJykge1xuICAgICAgICBkZWxldGUgb1twcm9wXTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9bcHJvcF0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIF9yZWN1cnNlKG9bcHJvcF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNsb25lZCA9IGNsb25lKG9iaik7XG4gIF9yZWN1cnNlKGNsb25lZCk7XG5cbiAgcmV0dXJuIGNsb25lZDtcblxufVxuXG50ZXN0KCdtYW5pZmVzdCBzYXZlJywgKCkgPT4ge1xuXG4gIGNvbnN0IG91dGRpciA9IGZzLm1rZHRlbXBTeW5jKHBhdGguam9pbihvcy50bXBkaXIoKSwgJ3NjaGVtYS10ZXN0cycpKTtcbiAgY29uc3QgbWFuaWZlc3RGaWxlID0gcGF0aC5qb2luKG91dGRpciwgJ21hbmlmZXN0Lmpzb24nKTtcblxuICBjb25zdCBhc3NlbWJseU1hbmlmZXN0OiBBc3NlbWJseU1hbmlmZXN0ID0ge1xuICAgIHZlcnNpb246ICd2ZXJzaW9uJ1xuICB9O1xuXG4gIE1hbmlmZXN0LnNhdmUoYXNzZW1ibHlNYW5pZmVzdCwgbWFuaWZlc3RGaWxlKTtcblxuICBjb25zdCBzYXZlZCA9IEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKG1hbmlmZXN0RmlsZSwgJ1VURi04JykpO1xuXG4gIGV4cGVjdChzYXZlZCkudG9FcXVhbChhc3NlbWJseU1hbmlmZXN0KTtcblxufSk7XG5cbnRlc3QoJ2Nsb3VkLWFzc2VtYmx5Lmpzb24uc2NoZW1hIGlzIGNvcnJlY3QnLCAoKSA9PiB7XG5cbiAgLy8gd2hlbiB3ZSBjb21wYXJlIHNjaGVtYXMgd2UgaWdub3JlIGNoYW5nZXMgdGhlXG4gIC8vIGRlc2NyaXB0aW9uIHRoYXQgaXMgZ2VuZXJhdGVkIGZyb20gdGhlIHRzIGRvY3N0cmluZ3MuXG4gIGNvbnN0IGRvY1N0cmluZ0ZpZWxkcyA9IFtcbiAgICAnZGVzY3JpcHRpb24nXG4gIF07XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgY29uc3Qgc2NoZW1hID0gcmVxdWlyZSgnLi4vc2NyaXB0cy91cGRhdGUtc2NoZW1hLmpzJyk7XG5cbiAgY29uc3QgZXhwZWN0ZWQgPSByZW1vdmVTdHJpbmdLZXlzKHNjaGVtYS5nZW5lcmF0ZSgpLCBkb2NTdHJpbmdGaWVsZHMpO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzXG4gIGNvbnN0IGFjdHVhbCA9IHJlbW92ZVN0cmluZ0tleXMocmVxdWlyZSgnLi4vc2NoZW1hL2Nsb3VkLWFzc2VtYmx5LnNjaGVtYS5qc29uJyksIGRvY1N0cmluZ0ZpZWxkcyk7XG5cbiAgdHJ5IHtcbiAgICBleHBlY3QoYWN0dWFsKS50b0VxdWFsKGV4cGVjdGVkKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gSSBjb3VsZG4ndCBmb3IgdGhlIGxpZmUgb2YgbWUgZmlndXJlIG91dCBob3cgdG8gcHJvdmlkZSBhZGRpdGlvbmFsIGVycm9yIG1lc3NhZ2VcbiAgICAvLyB0byBqZXN0Li4uYW55IGlkZWFzP1xuICAgIGVyci5tZXNzYWdlID0gYFdob29wcywgTG9va3MgbGlrZSB0aGUgc2NoZW1hIGhhcyBjaGFuZ2VkLiBEaWQgeW91IGZvcmdldCB0byBydW4gJ3lhcm4gdXBkYXRlLXNjaGVtYSc/XFxuXFxuJHtlcnIubWVzc2FnZX1gO1xuICAgIHRocm93IGVycjtcbiAgfVxufSk7XG5cbnRlc3QoJ21hbmlmZXN0IGxvYWQnLCAoKSA9PiB7XG4gIGNvbnN0IGxvYWRlZCA9IE1hbmlmZXN0LmxvYWQoZml4dHVyZSgnb25seS12ZXJzaW9uJykpO1xuICBleHBlY3QobG9hZGVkKS50b01hdGNoU25hcHNob3QoKTtcbn0pO1xuXG50ZXN0KCdtYW5pZmVzdCBsb2FkIGZhaWxzIGZvciBpbnZhbGlkIG5lc3RlZCBwcm9wZXJ0eScsICgpID0+IHtcbiAgZXhwZWN0KCgpID0+IE1hbmlmZXN0LmxvYWQoZml4dHVyZSgnaW52YWxpZC1uZXN0ZWQtcHJvcGVydHknKSkpLnRvVGhyb3coL0ludmFsaWQgYXNzZW1ibHkgbWFuaWZlc3QvKTtcbn0pO1xuXG50ZXN0KCdtYW5pZmVzdCBsb2FkIGZhaWxzIGZvciBpbnZhbGlkIGFydGlmYWN0IHR5cGUnLCAoKSA9PiB7XG4gIGV4cGVjdCgoKSA9PiBNYW5pZmVzdC5sb2FkKGZpeHR1cmUoJ2ludmFsaWQtYXJ0aWZhY3QtdHlwZScpKSkudG9UaHJvdygvSW52YWxpZCBhc3NlbWJseSBtYW5pZmVzdC8pO1xufSk7XG5cbnRlc3QoJ21hbmlmZXN0IGxvYWQgZmFpbHMgb24gaGlnaGVyIG1ham9yIHZlcnNpb24nLCAoKSA9PiB7XG4gIGV4cGVjdCgoKSA9PiBNYW5pZmVzdC5sb2FkKGZpeHR1cmUoJ2hpZ2gtdmVyc2lvbicpKSkudG9UaHJvdygvQ2xvdWQgYXNzZW1ibHkgc2NoZW1hIHZlcnNpb24gbWlzbWF0Y2gvKTtcbn0pO1xuXG4vLyBvbmNlIHdlIHN0YXJ0IGludHJvZHVjaW5nIG1pbm9yIHZlcnNpb24gYnVtcHMgdGhhdCBhcmUgY29uc2lkZXJlZFxuLy8gbm9uIGJyZWFraW5nLCB0aGlzIHRlc3QgY2FuIGJlIHJlbW92ZWQuXG50ZXN0KCdtYW5pZmVzdCBsb2FkIGZhaWxzIG9uIGhpZ2hlciBtaW5vciB2ZXJzaW9uJywgKCkgPT4ge1xuXG4gIGNvbnN0IG91dGRpciA9IGZzLm1rZHRlbXBTeW5jKHBhdGguam9pbihvcy50bXBkaXIoKSwgJ3NjaGVtYS10ZXN0cycpKTtcbiAgY29uc3QgbWFuaWZlc3RGaWxlID0gcGF0aC5qb2luKG91dGRpciwgJ21hbmlmZXN0Lmpzb24nKTtcblxuICBjb25zdCBuZXdWZXJzaW9uID0gc2VtdmVyLmluYyhNYW5pZmVzdC52ZXJzaW9uKCksICdtaW5vcicpO1xuICBleHBlY3QobmV3VmVyc2lvbikudG9CZVRydXRoeSgpO1xuXG4gIGlmIChuZXdWZXJzaW9uKSB7XG4gICAgY29uc3QgYXNzZW1ibHlNYW5pZmVzdDogQXNzZW1ibHlNYW5pZmVzdCA9IHtcbiAgICAgIHZlcnNpb246IG5ld1ZlcnNpb25cbiAgICB9O1xuXG4gICAgTWFuaWZlc3Quc2F2ZShhc3NlbWJseU1hbmlmZXN0LCBtYW5pZmVzdEZpbGUpO1xuXG4gICAgZXhwZWN0KCgpID0+IE1hbmlmZXN0LmxvYWQobWFuaWZlc3RGaWxlKSkudG9UaHJvdygvQ2xvdWQgYXNzZW1ibHkgc2NoZW1hIHZlcnNpb24gbWlzbWF0Y2gvKTtcbiAgfVxufSk7XG5cbi8vIG9uY2Ugd2Ugc3RhcnQgaW50cm9kdWNpbmcgcGF0Y2ggdmVyc2lvbiBidW1wcyB0aGF0IGFyZSBjb25zaWRlcmVkXG4vLyBub24gYnJlYWtpbmcsIHRoaXMgdGVzdCBjYW4gYmUgcmVtb3ZlZC5cbnRlc3QoJ21hbmlmZXN0IGxvYWQgZmFpbHMgb24gaGlnaGVyIHBhdGNoIHZlcnNpb24nLCAoKSA9PiB7XG5cbiAgY29uc3Qgb3V0ZGlyID0gZnMubWtkdGVtcFN5bmMocGF0aC5qb2luKG9zLnRtcGRpcigpLCAnc2NoZW1hLXRlc3RzJykpO1xuICBjb25zdCBtYW5pZmVzdEZpbGUgPSBwYXRoLmpvaW4ob3V0ZGlyLCAnbWFuaWZlc3QuanNvbicpO1xuXG4gIGNvbnN0IG5ld1ZlcnNpb24gPSBzZW12ZXIuaW5jKE1hbmlmZXN0LnZlcnNpb24oKSwgJ3BhdGNoJyk7XG4gIGV4cGVjdChuZXdWZXJzaW9uKS50b0JlVHJ1dGh5KCk7XG5cbiAgaWYgKG5ld1ZlcnNpb24pIHtcbiAgICBjb25zdCBhc3NlbWJseU1hbmlmZXN0OiBBc3NlbWJseU1hbmlmZXN0ID0ge1xuICAgICAgdmVyc2lvbjogbmV3VmVyc2lvblxuICAgIH07XG5cbiAgICBNYW5pZmVzdC5zYXZlKGFzc2VtYmx5TWFuaWZlc3QsIG1hbmlmZXN0RmlsZSk7XG5cbiAgICBleHBlY3QoKCkgPT4gTWFuaWZlc3QubG9hZChtYW5pZmVzdEZpbGUpKS50b1Rocm93KC9DbG91ZCBhc3NlbWJseSBzY2hlbWEgdmVyc2lvbiBtaXNtYXRjaC8pO1xuICB9XG59KTtcblxudGVzdCgnbWFuaWZlc3QgbG9hZCBmYWlscyBvbiBpbnZhbGlkIHZlcnNpb24nLCAoKSA9PiB7XG4gIGV4cGVjdCgoKSA9PiBNYW5pZmVzdC5sb2FkKGZpeHR1cmUoJ2ludmFsaWQtdmVyc2lvbicpKSkudG9UaHJvdygvSW52YWxpZCBzZW12ZXIgc3RyaW5nLyk7XG59KTtcblxudGVzdCgnbWFuaWZlc3QgbG9hZCBzdWNjZWVkcyBvbiB1bmtub3duIHByb3BlcnRpZXMnLCAoKSA9PiB7XG4gIGNvbnN0IG1hbmlmZXN0ID0gTWFuaWZlc3QubG9hZChmaXh0dXJlKCd1bmtub3duLXByb3BlcnR5JykpO1xuICBleHBlY3QobWFuaWZlc3QudmVyc2lvbikudG9FcXVhbCgnMC4wLjAnKTtcbn0pO1xuXG50ZXN0KCdzdGFjay10YWdzIGFyZSBkZXNlcmlhbGl6ZWQgcHJvcGVybHknLCAoKSA9PiB7XG5cbiAgY29uc3QgbTogQXNzZW1ibHlNYW5pZmVzdCA9IE1hbmlmZXN0LmxvYWQoZml4dHVyZSgnd2l0aC1zdGFjay10YWdzJykpO1xuXG4gIGlmIChtLmFydGlmYWN0cz8uc3RhY2s/Lm1ldGFkYXRhPy5Bd3NDZGtQbGF5Z3JvdW5kQmF0Y2hbMF0uZGF0YSkge1xuICAgIGNvbnN0IGVudHJ5ID0gbS5hcnRpZmFjdHMuc3RhY2subWV0YWRhdGEuQXdzQ2RrUGxheWdyb3VuZEJhdGNoWzBdLmRhdGEgYXMgU3RhY2tUYWdzTWV0YWRhdGFFbnRyeTtcbiAgICBleHBlY3QoZW50cnlbMF0ua2V5KS50b0VxdWFsKCdoZWxsbycpO1xuICAgIGV4cGVjdChlbnRyeVswXS52YWx1ZSkudG9FcXVhbCgnd29ybGQnKTtcbiAgfVxuICBleHBlY3QobS52ZXJzaW9uKS50b0VxdWFsKCcwLjAuMCcpO1xuXG59KTtcblxudGVzdCgnY2FuIGFjY2VzcyByYW5kb20gbWV0YWRhdGEnLCAoKSA9PiB7XG5cbiAgY29uc3QgbG9hZGVkID0gTWFuaWZlc3QubG9hZChmaXh0dXJlKCdyYW5kb20tbWV0YWRhdGEnKSk7XG4gIGNvbnN0IHJhbmRvbUFycmF5ID0gbG9hZGVkLmFydGlmYWN0cz8uc3RhY2subWV0YWRhdGE/LkF3c0Nka1BsYXlncm91bmRCYXRjaFswXS5kYXRhO1xuICBjb25zdCByYW5kb21OdW1iZXIgPSBsb2FkZWQuYXJ0aWZhY3RzPy5zdGFjay5tZXRhZGF0YT8uQXdzQ2RrUGxheWdyb3VuZEJhdGNoWzFdLmRhdGE7XG4gIGNvbnN0IHJhbmRvbU1hcCA9IGxvYWRlZC5hcnRpZmFjdHM/LnN0YWNrLm1ldGFkYXRhPy5Bd3NDZGtQbGF5Z3JvdW5kQmF0Y2hbMl0uZGF0YTtcblxuICBleHBlY3QocmFuZG9tQXJyYXkpLnRvRXF1YWwoWyc0MiddKTtcbiAgZXhwZWN0KHJhbmRvbU51bWJlcikudG9FcXVhbCg0Mik7XG4gIGV4cGVjdChyYW5kb21NYXApLnRvRXF1YWwoe1xuICAgIGtleTogJ3ZhbHVlJ1xuICB9KTtcblxuICBleHBlY3QocmFuZG9tTWFwKS50b0JlVHJ1dGh5KCk7XG5cbiAgaWYgKHJhbmRvbU1hcCkge1xuICAgIGV4cGVjdCgocmFuZG9tTWFwIGFzIGFueSkua2V5KS50b0VxdWFsKCd2YWx1ZScpO1xuICB9XG5cbn0pO1xuIl19